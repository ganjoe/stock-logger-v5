import sys
import os
import shutil
from datetime import datetime, timedelta
import random
import uuid

# Pfad-Setup damit Imports klappen
sys.path.append(os.getcwd())

from py_tradeobject.core import TradeObject, TradeStatus
from py_tradeobject.models import TradeTransaction, TransactionType

# Konfiguration
DATA_DIR = "./data/trades"

def clean_slate():
    """LÃ¶scht alte Testdaten fÃ¼r einen frischen Start."""
    if os.path.exists(DATA_DIR):
        shutil.rmtree(DATA_DIR)
    print(f"ðŸ§¹ Cleaned directory: {DATA_DIR}")

def generate_synthetic_trade(ticker, days_ago, result_type="WIN"):
    """
    Erzeugt einen kompletten Trade-Zyklus ohne Broker.
    result_type: 'WIN', 'LOSS', 'OPEN_WIN', 'OPEN_LOSS'
    """
    # 1. TradeObject erstellen
    # Wir Ã¼bergeben explizit den Test-Ordner
    trade = TradeObject(ticker=ticker, storage_dir=DATA_DIR)
    
    # Zeitstempel basteln
    entry_time = datetime.now() - timedelta(days=days_ago)
    exit_time = entry_time + timedelta(days=random.randint(1, 5))
    
    # Preis-Logik simulieren
    base_price = random.uniform(50, 200)
    qty = 100
    
    if result_type == "WIN":
        exit_price = base_price * 1.15 # +15%
        status = TradeStatus.CLOSED
    elif result_type == "LOSS":
        exit_price = base_price * 0.92 # -8% (Stop Loss)
        status = TradeStatus.CLOSED
    elif "OPEN" in result_type:
        exit_price = None # Noch kein Exit
        status = TradeStatus.OPEN
        # Preis fÃ¼r Simulation (wird hier nicht gespeichert, nur Status)
        current_sim_price = base_price * (1.05 if "WIN" in result_type else 0.95)
    
    # 2. Transaktionen injizieren (Wir umgehen den Broker und schreiben direkt in den State)
    
    # ENTRY
    tx_entry = TradeTransaction(
        id=str(uuid.uuid4())[:8],
        timestamp=entry_time,
        type=TransactionType.ENTRY,
        quantity=qty, # Long
        price=base_price,
        commission=1.0,
        slippage=0.0
    )
    trade._state.transactions.append(tx_entry)
    
    # EXIT (Nur wenn nicht OPEN)
    if status == TradeStatus.CLOSED:
        tx_exit = TradeTransaction(
            id=str(uuid.uuid4())[:8],
            timestamp=exit_time,
            type=TransactionType.EXIT,
            quantity=-qty, # Sell all
            price=exit_price,
            commission=1.0,
            slippage=0.1
        )
        trade._state.transactions.append(tx_exit)
        trade._state.status = TradeStatus.CLOSED
        
    else:
        # Bei OPEN setzen wir den Status manuell
        trade._state.status = TradeStatus.OPEN
        trade._state.active_orders["mock-oid"] = "STOP" # Fake Active Order

    # 3. Metadaten setzen
    trade._state.initial_stop_price = base_price * 0.90
    trade._state.notes = f"Simulated {result_type} Trade generated by Seeder"
    
    # 4. Speichern (Das lÃ¶st die JSON-Erstellung aus)
    trade.save()
    
    # PnL berechnen (nur fÃ¼r Konsolen-Output)
    metrics = trade.metrics 
    # Hinweis: Bei OPEN Trades ist PnL hier 0, weil metrics() ohne Live-Preis rechnet.
    # Das ist okay, das Portfolio-Modul muss spÃ¤ter den Live-Preis injecten.
    
    print(f"ðŸŒ± Generated {ticker}: {result_type} | Status: {status.value} | ID: {trade.id}")

def run_seed():
    clean_slate()
    print("ðŸš€ Starting Data Seeding...")
    
    # Szenario 1: Alte Historie (Geschlossene Trades)
    generate_synthetic_trade("NVDA", days_ago=20, result_type="WIN")
    generate_synthetic_trade("TSLA", days_ago=18, result_type="LOSS")
    generate_synthetic_trade("AAPL", days_ago=15, result_type="WIN")
    generate_synthetic_trade("AMZN", days_ago=10, result_type="WIN")
    generate_synthetic_trade("META", days_ago=8,  result_type="LOSS") # Drawdown simulieren
    
    # Szenario 2: Aktives Portfolio (Offene Trades)
    generate_synthetic_trade("MSFT", days_ago=2, result_type="OPEN_WIN")
    generate_synthetic_trade("GOOGL", days_ago=1, result_type="OPEN_LOSS")
    
    print("\nâœ… Done! Check folder './data/trades'")

if __name__ == "__main__":
    run_seed()